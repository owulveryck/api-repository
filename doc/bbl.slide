DTO, DAO, API, SLO and Go
Designing a REST API driven by the objectives
15:04 7 Dec 2018

Olivier Wulveryck
Consultant / SRE, Octo Technology
owulveryck@octo.com
https://blog.owulveryck.info
@owulveryck

* Foreword

- Pure Go without magic (= no framework)

- Dependencies: 

.link  https://github.com/google/uuid github.com/google/uuid 
.link  https://github.com/kelseyhightower/envconfig github.com/kelseyhightower/envconfig
.link  https://github.com/stretchr/testify/assert github.com/stretchr/testify/assert

* Use case

* What's the business value

As a retailer, I want to expose a capacity that will allow my clients and partners 
to send their product items to my platform and to get them back with some value added.

- The capacity is exposed through a REST API
- Only the POST request is addressed in this talk

* The team

- The Dev: her/his goal is to develop a great product that provide the best value for the company. She/He talks about software quality and about new features.
- The *SRE* (_me_): her/his goal is to create ultra-scalable and highly reliable software systems. He talks about infrastructure, elasticity, cloud and automation.

* Implementation

* Functional element

An item in a catalog can be anything that is referenced by an ID. Ex a product:

.link https://support.google.com/merchants/answer/7052112?hl=en

.image assets/google_basic_product2.png 400 _
#html assets/quickreference.html

* The Data Transfer Objects

We will store any object that can gives its own `ID` and seriallize itself in the json format.

.code ../object/interface.go /START_IDER OMIT/,/END_IDER OMIT/

And handling bulk upload using a stateful iterator for convenience...

.code ../object/interface.go /START_ITERATOR OMIT/,/END_ITERATOR OMIT/

* The product implementation

`Product` fulfils the `IDer` interface:
.code ../business/product.go /START_PRODUCT OMIT/,/END_PRODUCT OMIT/

* The Data Access Object

From Wikipedia:

  In computer software, a data access object (DAO) is an object that provides 
  an abstract interface to some type of database or other persistence mechanism. 

  By mapping application calls to the persistence layer, 
  the DAO provides some specific data operations without exposing details of the database.

Which is described as an interface

.code ../dao/saver.go /START_SAVER OMIT/,/END_SAVER OMIT/

* What about the SRE

SRE wants the system to be *reliable* and *available*. 

- Indicators are used to measure availability
- Objectives are used to measure reliability

If the system is more reliable than expected, more risks are allowed: this is the *error* *budget*.

The *error* *budget* is spend in risky operations (deploying more often, improving the infrastructure or implementing a new deployment system to reduce toil, ...). 

* Concepts of SLOs and SLIs

.link https://landing.google.com/sre/sre-book/chapters/service-level-objectives/ From the Chapter 4 of the SRE BOOK (Service Level Objectives)

- SLI 

An SLI is a service level indicator — a carefully defined quantitative measure of some aspect of the level of service that is provided.

- SLO 

An SLO is a service level objective: a target value or range of values for a service level that is measured by an SLI. A natural structure for SLOs is thus SLI ≤ target, or lower bound ≤ SLI ≤ upper bound.

* SLO Document of our API

* Availability

- SLI 

The proportion of successful requests, as measured from the load balancer metrics. Any HTTP status other than 500–599 is considered successful.

  count of "api" http_requests which do not have a 5XX status code
      divided by
  count of all "api" http_requests

- Objective

97% success

* Latency

- SLI

The proportion of sufficiently fast requests, as measured from the load balancer metrics. “Sufficiently fast” is defined as < 400 ms, or < 750 ms.

  count of "api" http_requests with a duration less than or equal to "0.4" seconds
      divided by
  count of all "api" http_requests

  count of "api" http_requests with a duration less than or equal to "0.75" seconds
      divided by
  count of all "api" http_requests

- SLO

90% of requests < 400 ms
99% of requests < 750 ms

* Measurement method

* Principle

.image assets/injector.png

* Implementation

.code ../injector/injector.go /START_SLO OMIT/,/END_SLO OMIT/
.code ../injector/injector.go /START_EVALUATE OMIT/,/END_EVALUATE OMIT/
.code ../injector/injector.go /START_SEND OMIT/,/END_SEND OMIT/

* For testing

.code my/myslo.go /START_SLO OMIT/,/END_SLO OMIT/

* Developing the API

* Dummy DAO (for testing purpose)

.code ../dao/dummy/storage.go /START_INIT OMIT/,/END_INIT OMIT/
.code ../dao/dummy/storage.go /START_OBJECT OMIT/,/END_OBJECT OMIT/

* Handler

A Handler responds to an HTTP request.

.code test1/handler/simple.go /START_HANDLER OMIT/,/END_HANDLER OMIT/

* Validating

.code -numbers -edit test1/simple.go /START_TEST_SERVER OMIT/,/END_TEST_SERVER OMIT/ 
.play -numbers -edit test1/simple.go /START_SEND OMIT/,/END_SEND OMIT/ 

* Feature Request: I need a bulk!

.code test1/handler/bundle.go /START_HANDLER OMIT/,/END_HANDLER OMIT/

* Validating

.code -numbers -edit test1/bundle.go /START_TEST_SERVER OMIT/,/END_TEST_SERVER OMIT/ 
.play -numbers -edit test1/bundle.go /START_SEND OMIT/,/END_SEND OMIT/ 

* What if you ask the SRE to develop it?

* Let's implement concurrency in the API

.link http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/ Handling 1 Million Requests per Minute with Go

* Other DAO implementations

* Filesystem

.code ../dao/fs/storage.go /START/,/END/ 

* Google Cloud Storage

.code ../dao/gcs/google_storage.go /START_IMPORT OMIT/,/END_IMPORT OMIT/
.code ../dao/gcs/google_storage.go /START_DEFINITION OMIT/,/END_DEFINITION OMIT/
.code ../dao/gcs/google_storage.go /START_SAVE OMIT/,/END_SAVE OMIT/

* Sessions

* Conclusions

* Documenting the API does not give any guarantee about its usage

_Murphy's_ _Law_:

  things will go wrong in any given situation, if you give them a chance 

* HTTP codes used along with this presentation

  egrep -hro 'http.Status[A-Za-z]+' * | sort -u

  - StatusOK                           = 200 // RFC 7231, 6.3.1
  - StatusCreated                      = 201 // RFC 7231, 6.3.2
  - StatusAccepted                     = 202 // RFC 7231, 6.3.3
  - StatusMultiStatus                  = 207 // RFC 4918, 11.1
  
  - StatusBadRequest                   = 400 // RFC 7231, 6.5.1
  - StatusNotFound                     = 404 // RFC 7231, 6.5.4
  - StatusMethodNotAllowed             = 405 // RFC 7231, 6.5.5
  - StatusRequestEntityTooLarge        = 413 // RFC 7231, 6.5.11
  - StatusUnprocessableEntity          = 422 // RFC 4918, 11.2
  
  - StatusInternalServerError          = 500 // RFC 7231, 6.6.1

* References

.link github.com/owulveryck/api-repository
.link https://talks.godoc.org/github.com/owulveryck/api-repository/doc/bbl.slide
.link https://godoc.org/github.com/owulveryck/api-repository

   # go get github.com/owulveryck/api-repository 
   # present

.image http://www.unitag.io/qreator/generate?crs=xnjFkEn%252FP85fCPDXJ%252FXXKg5g6yQi7H4qzUlRVUntU035Re8CX7iHj071HbqF%252BCfYW0fkByoDtlWAYEP%252FkF2dipjP8Ux69VtYkusoonlKTAkgSRnmfwEzhpz3ulb%252BfgcH8xxrpOTbfLtqZS7YE5Pf9g%253D%253D&crd=fhOysE0g3Bah%252BuqXA7NPQ%252BnMbKAfwrOmvCu%252Fck4sYh0tYbiaJjNiLznCAt%252Fz8zSIOwn%252FtIMh1rhiigFow7meWwUQGD3HT6BAW9aa%252FtrpQJBG6VBs7QRL1sGQdgnrfJiYRhblqsYYpMYZvzutihyh5M5Ab74LILbnkcnwmwaV3xM%253D

* Misc

.link https://www.kaggle.com/rtatman/universal-product-code-database
.link https://www.kaggle.com/PromptCloudHQ/innerwear-data-from-victorias-secret-and-others#ae_com.csv
