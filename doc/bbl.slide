DTO, DAO, API, SLO and Go
Coding a REST API in Go driven by the objectives
15:04 7 Dec 2018

Olivier Wulveryck
Consultant Ops, Octo Technology
owulveryck@octo.com
https://blog.owulveryck.info
@owulveryck

* Foreword

- Pure Go without magic (= no framework)

- Dependencies: 

.link  https://github.com/google/uuid github.com/google/uuid 
.link  https://github.com/kelseyhightower/envconfig github.com/kelseyhightower/envconfig
.link  https://github.com/stretchr/testify/assert github.com/stretchr/testify/assert

* Use case

* What's the business value

As a retailer, I want to provide a capacity to my business partners.
This capacity will handle send me their catalog items.
I will then add some value on their products such as selling them or
applying some business intelligence.


* Constraints

- The capacity must be exposed as a REST Api.
- I want the application to be elastic (to handle the sales for example).

I need to take care of the TCO: 

- Maintenance should be cheap: no toil for SRE;
- Onboarding of new developers should be easy: the architecture should be explained easily;
- Avoid vendor locking...

* Implementation

* Functional element

An item in a catalog can be anything that is referenced by an ID. Ex a product:

.link https://support.google.com/merchants/answer/7052112?hl=en

.html assets/quickreference.html

* The Data Transfer Object

We will store any object that can gives its own `ID` and seriallize itself in the json format.

.code ../object/interface.go /START_IDER OMIT/,/END_IDER OMIT/

* Handling a bulk of elements

Using a stateful iterator for convenience...

.code ../object/interface.go /START_ITERATOR OMIT/,/END_ITERATOR OMIT/

* The product implementation

`Product` fulfils the `IDer` interface:
.code ../business/product.go /START_PRODUCT OMIT/,/END_PRODUCT OMIT/


* The Data Access Object

From Wikipedia:

  In computer software, a data access object (DAO) is an object that provides 
  an abstract interface to some type of database or other persistence mechanism. 

  By mapping application calls to the persistence layer, 
  the DAO provides some specific data operations without exposing details of the database.

* The interface of the DAO

.code ../dao/saver.go /START_SAVER OMIT/,/END_SAVER OMIT/

* The service level objectives of the API

* Concepts of SLOs and SLIs

.link https://landing.google.com/sre/sre-book/chapters/service-level-objectives/ From the Chapter 4 of the SRE BOOK (Service Level Objectives)

- SLI 

An SLI is a service level indicator — a carefully defined quantitative measure of some aspect of the level of service that is provided.

- SLO 

An SLO is a service level objective: a target value or range of values for a service level that is measured by an SLI. A natural structure for SLOs is thus SLI ≤ target, or lower bound ≤ SLI ≤ upper bound.

* SLO Document of our API

* Availability

- SLI 

The proportion of successful requests, as measured from the load balancer metrics. Any HTTP status other than 500–599 is considered successful.

  count of "api" http_requests which do not have a 5XX status code
      divided by
  count of all "api" http_requests

- Objective

97% success

* Latency

- SLI

The proportion of sufficiently fast requests, as measured from the load balancer metrics. “Sufficiently fast” is defined as < 400 ms, or < 850 ms.

  count of "api" http_requests with a duration less than or equal to "0.4" seconds
      divided by
  count of all "api" http_requests

  count of "api" http_requests with a duration less than or equal to "0.85" seconds
      divided by
  count of all "api" http_requests

- SLO

90% of requests < 400 ms
99% of requests < 850 ms

* First attempt: 

* Dummy DAO (for testing purpose)

.code ../dao/dummy/storage.go /START_INIT OMIT/,/END_INIT OMIT/
.code ../dao/dummy/storage.go /START_OBJECT OMIT/,/END_OBJECT OMIT/

* Handler

.code test1/handler/simple.go /START_PACKAGE OMIT/,/END_PACKAGE OMIT/
.code test1/handler/simple.go /START_HANDLER OMIT/,/END_HANDLER OMIT/

* Validating

.code -numbers -edit test1/main.go /START_IMPORT OMIT/,/END_IMPORT OMIT/ 
.play -numbers -edit test1/main.go /START_MAIN2 OMIT/,/END_MAIN OMIT/ 

* Concurrent requests

.play -numbers -edit test2/main.go /START_MAIN2 OMIT/,/END_MAIN OMIT/ 

* Measure the SLO

.play -numbers -edit test3/main.go /START_MAIN2 OMIT/,/END_MAIN OMIT/ 

* I need a bulk!

* Other DAO implementations

* Filesystem

.code ../dao/fs/storage.go /START/,/END/ 

* Google Cloud Storage

.code ../dao/gcs/google_storage.go /START_IMPORT OMIT/,/END_IMPORT OMIT/
.code ../dao/gcs/google_storage.go /START_DEFINITION OMIT/,/END_DEFINITION OMIT/
.code ../dao/gcs/google_storage.go /START_SAVE OMIT/,/END_SAVE OMIT/

* Sessions

* Conclusions

* Documenting the API does not give any guarantee about its usage

_Murphy's_ _Law_:

  things will go wrong in any given situation, if you give them a chance 

* HTTP codes used along with this presentation

  egrep -hro 'http.Status[A-Za-z]+' * | sort -u

  - StatusOK                           = 200 // RFC 7231, 6.3.1
  - StatusCreated                      = 201 // RFC 7231, 6.3.2
  - StatusAccepted                     = 202 // RFC 7231, 6.3.3
  - StatusMultiStatus                  = 207 // RFC 4918, 11.1
  
  - StatusBadRequest                   = 400 // RFC 7231, 6.5.1
  - StatusNotFound                     = 404 // RFC 7231, 6.5.4
  - StatusMethodNotAllowed             = 405 // RFC 7231, 6.5.5
  - StatusRequestEntityTooLarge        = 413 // RFC 7231, 6.5.11
  - StatusUnprocessableEntity          = 422 // RFC 4918, 11.2
  
  - StatusInternalServerError          = 500 // RFC 7231, 6.6.1
